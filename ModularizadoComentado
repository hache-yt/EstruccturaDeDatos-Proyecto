#include <iostream>
#include <fstream>
#include <string>
#include <cmath>
using namespace std;

/* ============================================================
   ðŸ“˜ MÃ“DULO 1: LISTA ENLAZADA â€“ GESTOR DE ECUACIONES
   ============================================================ */
struct NodoEcuacion {
    int id;               // Identificador de la ecuaciÃ³n
    string expresion;     // EcuaciÃ³n en texto
    string complejidad;   // Complejidad (Alta/Baja)
    NodoEcuacion* sig;    // Puntero al siguiente nodo
};

class ListaEcuaciones {
private:
    NodoEcuacion* inicio; // Apunta al primer nodo

public:
    ListaEcuaciones() : inicio(NULL) {}

    // Agrega una ecuaciÃ³n a la lista
    void insertarEcuacion(int id, string expresion, string complejidad) {
        NodoEcuacion* nueva = new NodoEcuacion{id, expresion, complejidad, NULL};
        if (inicio == NULL) {
            inicio = nueva;
        } else {
            NodoEcuacion* actual = inicio;
            while (actual->sig != NULL)
                actual = actual->sig;
            actual->sig = nueva;
        }
        cout << "âœ… Ecuacion agregada: " << expresion << " (" << complejidad << ")\n";
    }

    // Buscar ecuaciÃ³n por ID
    NodoEcuacion* buscarEcuacion(int id) {
        NodoEcuacion* actual = inicio;
        while (actual != NULL) {
            if (actual->id == id)
                return actual;
            actual = actual->sig;
        }
        return NULL;
    }

    // Mostrar todas las ecuaciones
    void mostrarEcuaciones() {
        NodoEcuacion* actual = inicio;
        cout << "\nðŸ“˜ Ecuaciones registradas:\n";
        while (actual != NULL) {
            cout << "ID: " << actual->id << " | " << actual->expresion 
                 << " | Complejidad: " << actual->complejidad << endl;
            actual = actual->sig;
        }
    }

    // Guardar en archivo
    void guardarArchivo() {
        ofstream archivo("ecuaciones.txt");
        NodoEcuacion* actual = inicio;
        while (actual != NULL) {
            archivo << actual->id << "," << actual->expresion << "," << actual->complejidad << endl;
            actual = actual->sig;
        }
        archivo.close();
        cout << "ðŸ’¾ Ecuaciones guardadas correctamente.\n";
    }
};

/* ============================================================
   âš™ï¸ MÃ“DULO 2: COLA DE PRIORIDAD â€“ PLANIFICADOR
   ============================================================ */
struct NodoCola {
    NodoEcuacion ecuacion; // EcuaciÃ³n almacenada
    NodoCola* sig;         // Puntero al siguiente nodo
};

class ColaPrioridad {
private:
    NodoCola* frente; // Apunta al primer nodo (mayor prioridad)

public:
    ColaPrioridad() : frente(NULL) {}

    // Encolar segÃºn prioridad
    void encolar(NodoEcuacion eq) {
        NodoCola* nuevo = new NodoCola{eq, NULL};
        if (frente == NULL || eq.complejidad == "Alta") {
            nuevo->sig = frente;
            frente = nuevo;
        } else {
            NodoCola* actual = frente;
            while (actual->sig != NULL && actual->sig->ecuacion.complejidad != "Baja")
                actual = actual->sig;
            nuevo->sig = actual->sig;
            actual->sig = nuevo;
        }
        cout << "ðŸ“¥ Encolada ecuacion: " << eq.expresion << endl;
    }

    // Desencolar ecuaciÃ³n
    NodoEcuacion desencolar() {
        if (frente == NULL) {
            cout << "âš ï¸ No hay ecuaciones en cola.\n";
            return NodoEcuacion{-1, "", "", NULL};
        }
        NodoCola* temp = frente;
        frente = frente->sig;
        NodoEcuacion eq = temp->ecuacion;
        delete temp;
        return eq;
    }

    // Verifica si la cola estÃ¡ vacÃ­a
    bool estaVacia() { return frente == NULL; }

    // Mostrar cola completa
    void mostrarCola() {
        NodoCola* actual = frente;
        cout << "\nðŸ“¤ Cola de prioridad:\n";
        while (actual != NULL) {
            cout << actual->ecuacion.expresion << " (" << actual->ecuacion.complejidad << ")\n";
            actual = actual->sig;
        }
    }
};

/* ============================================================
   ðŸ’¾ MÃ“DULO 3: PILA â€“ GESTOR DE MEMORIA TEMPORAL
   ============================================================ */
struct NodoPila {
    string variable;  // Nombre de variable o dato temporal
    NodoPila* sig;    // Puntero al siguiente
};

class PilaMemoria {
private:
    NodoPila* tope; // Apunta al nodo superior

public:
    PilaMemoria() : tope(NULL) {}

    // Agregar elemento
    void push(string variable) {
        NodoPila* nuevo = new NodoPila{variable, tope};
        tope = nuevo;
        cout << "ðŸ§  Memoria asignada: " << variable << endl;
    }

    // Quitar elemento
    void pop() {
        if (tope != NULL) {
            cout << "ðŸ—‘ï¸ Liberando memoria: " << tope->variable << endl;
            NodoPila* temp = tope;
            tope = tope->sig;
            delete temp;
        }
    }

    // Mostrar contenido
    void mostrarPila() {
        NodoPila* actual = tope;
        cout << "\nðŸ“š Variables en memoria:\n";
        while (actual != NULL) {
            cout << actual->variable << endl;
            actual = actual->sig;
        }
    }
};

/* ============================================================
   ðŸ§® MÃ“DULO 4: FUNCIÃ“N â€“ RESOLVER ECUACIÃ“N
   ============================================================ */
void resolverEcuacion(NodoEcuacion eq, PilaMemoria& pila) {
    cout << "\nðŸ” Resolviendo: " << eq.expresion << endl;
    pila.push("Datos temporales de " + eq.expresion);

    if (eq.complejidad == "Alta") {
        double a, b, c;
        cout << "Ingrese coeficientes a, b, c: ";
        cin >> a >> b >> c;
        double D = pow(b, 2) - 4 * a * c;

        if (D >= 0) {
            double x1 = (-b + sqrt(D)) / (2 * a);
            double x2 = (-b - sqrt(D)) / (2 * a);
            cout << "Raices reales: x1 = " << x1 << ", x2 = " << x2 << endl;
        } else {
            cout << "No existen soluciones reales.\n";
        }
    } else {
        double a, b;
        cout << "Ingrese coeficientes a y b: ";
        cin >> a >> b;
        cout << "Solucion: x = " << -b / a << endl;
    }

    pila.pop();
    cout << "âœ… Ecuacion resuelta.\n";
}

/* ============================================================
   ðŸ–¥ï¸ MÃ“DULO 5: FUNCIÃ“N PRINCIPAL â€“ MENÃš GENERAL
   ============================================================ */
int main() {
    ListaEcuaciones lista;
    ColaPrioridad cola;
    PilaMemoria pila;

    int opcion, id = 1;
    string expresion, complejidad;

    do {
        cout << "\n===== SISTEMA DE GESTION DE PROCESOS MATEMATICOS =====\n";
        cout << "1. Registrar ecuacion\n2. Mostrar ecuaciones\n3. Encolar ecuacion\n";
        cout << "4. Mostrar cola\n5. Resolver ecuacion\n6. Guardar ecuaciones\n0. Salir\n";
        cout << "Seleccione una opcion: ";
        cin >> opcion;

        switch (opcion) {
        case 1:
            cout << "Ingrese la ecuacion: ";
            cin.ignore();
            getline(cin, expresion);
            cout << "Complejidad (Alta/Baja): ";
            cin >> complejidad;
            lista.insertarEcuacion(id, expresion, complejidad);
            id++;
            break;

        case 2:
            lista.mostrarEcuaciones();
            break;

        case 3: {
            int idBuscar;
            cout << "Ingrese el ID de la ecuacion a encolar: ";
            cin >> idBuscar;
            NodoEcuacion* eq = lista.buscarEcuacion(idBuscar);
            if (eq != NULL)
                cola.encolar(*eq);
            else
                cout << "âŒ Ecuacion no encontrada.\n";
            break;
        }

        case 4:
            cola.mostrarCola();
            break;

        case 5:
            if (!cola.estaVacia()) {
                NodoEcuacion eq = cola.desencolar();
                resolverEcuacion(eq, pila);
            } else {
                cout << "âš ï¸ No hay ecuaciones pendientes.\n";
            }
            break;

        case 6:
            lista.guardarArchivo();
            break;

        case 0:
            cout << "\nðŸ‘‹ Fin de la simulacion.\n";
            break;

        default:
            cout << "Opcion invalida.\n";
        }

    } while (opcion != 0);

    return 0;
}
